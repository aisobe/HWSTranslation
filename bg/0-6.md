# Масиви

Масивите ти позволяват да групираш заедно много стойности в една колекция, а след това можеш да достъпиш тези стойности посредством тяхната позиция в колекцията. Swift използва автоматичен извод на тип (т.нар. _Type inference_), за да разбере какъв e типът на данни в масива, например:

    var evenNumbers = [2, 4, 6, 8]
    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]

Както може да се види, Swift използва скоби, за да маркира началото и края на масив, и всеки елемент в масива е разделен със запетая.

Когато става въпрос за четене на елементи от масив, ето каква е уловката: Swift започва да брои от 0. Това означава, че първият елемент е 0, вторият елемент е 1, третият е 2 и т.н. Опитай се да поставиш следния код в своя playground файл:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    songs[0]
    songs[1]
    songs[2]

Това ще отпечата "Shake It Off", "You Belong with Me" и "Back to December" в панела за резултати.

Позицията на даден елемент в масив се нарича негов индекс и можеш да прочетеш всеки елемент от масива като просто зададеш няговия индекс. Обаче, трябва да внимаваш: нашият масив има три елемента, което означава, че индексите 0, 1 и 2 работят чудесно. Но ако се опиташ да прочетеш елемент с инсекс 3 (`songs[3]`), твоята playground програма ще спре да работи, а ако се опиташ да направиш това в истинско приложение, то ще претърпи т.нар. "crash"!

Тъй като създаде масива си, като му даде три символни низа, Swift знае, че това е масив от strings. Можеш да провериш, че е така, като използваш специална команда в своя playground, която ще отпечата типа данни на която и да е променлива, например:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December"]
    type(of: songs)

Това ще отпечата `Array<String>.Type` в панела за резултати, показвайки ти, че Swift възприема `songs` като масив от strings.

Нека да кажем, че сме направили грешка и случайно сме сложили число в края на масива. Опитай това и виж какво ще се отпечата в панела за резултати:

    var songs = ["Shake it Off", "You Belong with Me", "Back to December", 3]
    type(of: songs)

Този път ще видиш грешка. Грешката не е защото Swift не може да работи със смесени масиви като този - ще ти покажа как става това след секунда! - а защото Swift се опитва да ни бъде полезен. Съобщението за грешка, което ще видиш, е “heterogenous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional.”. Или, на чист Български, "изглежда сякаш този масив е предназначен да съдържа много типове от данни - ако наистина имаш това предвид, моля отбележи го изрично."

Типовата безопаснот (_"Type safety"_) е важна и макар че е чудесно, че в Swift масивите могат да съдържат каквито и да е данни, специално този случай беше по случайност. За щастие, както вече споменах, можеш да използваш анотация на типа, за да уточниш точно какъв какви данни искаш да съхранява твоя масив. За да укажеш типа на масив, напиши типа данни, който искаш да съхраняваш със скоби около него, ето така:

    var songs: [String] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

След като вече казхме на Swift, че искаме да съхраняваме само strings в масива, езикът винаги ще откаже да изпълни кода, тъй като 3 не е символен низ.

Ако наистина искаш масив, който съхранява каквито и да е данни, използвай специалния тип `Any` ето така:

    var songs: [Any] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

## Създаване на масиви

Ако създадеш масив, използвайки синтаксиса показан по-горе, Swift създава масива и го запълва със зададените стойности. Нещата не са толкова прости ако искаш да създадеш масива и да го запълниш в последствие - този синтаксис не работи:

    var songs: [String]
    songs[0] = "Shake it Off"

Причината е такава, че може би ще ти изглежда ненужно педантична на пръв поглед, но в същността си тя има дълбоки последствия за производителността на кода, така че се опасявам, че трябва просто да я приемеш. Казано на кратко, пишейки `var songs: [String]` казваш на Swift "променливата `songs` ще съдържа масив от strings" но това не създава този масив. Не алокира никаква RAM памет и не извършва работа по създаването на масива. Просто казва, че в някакъв момент масив ще има и той ще съдържа strings.

Има няколко начина да го направим правилно и този, който е вероятно е най-лесно разбираемия в момента, е:

    var songs: [String] = []

Той използва анотация на типа, за да покаже ясно, че искаме масив от strings и присвоява празен масив (това е `[]` частта) към нея.

Често ще виждаш и тази конструкция:

    var songs = [String]()

Тя обозначава същото нещо: `()` казва на Swift, че искаме да създадем въпросния масив, който след това е присвоен на `songs` с помощта на автоматичния извод на тип. Тази опция е с два символа по-кратка, така че не е изненада, че програмистите я предпочитат!

## Оператори за работа с масиви

Можеш да използваш ограничен набор от оператори върху масиви. Например можеш да съединиш два масива като използваш оператора + ето така:

    var songs = ["Shake it Off", "You Belong with Me", "Love Story"]
    var songs2 = ["Today was a Fairytale", "Welcome to New York", "Fifteen"]
    var both = songs + songs2

Също така можеш да използваш += за да добавиш и присвоиш, ето така:

    both += ["Everything has Changed"]
