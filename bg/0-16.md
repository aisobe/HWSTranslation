# Класове

Swift има и друг начин за моделиране на сложни типове данни, наречен класове. Те изглеждат подобно на структурите, но имат редица важни разлики, включително:

-   Не получаваш автоматично инициализатори за данните на класовете си; трябва да ги създадеш сам.
-   Можеш да зададеш, че класът е базиран на друг клас, добавяйки нови неща, които искаш.
-   Когато създаваш инстанция на клас, тя е обект. Ако копираш този обект двете копия ще сочат към едно и също място - ако промениш едното копие, другото също се променя.

И трите неща представляват огромни разлики, така че ще ги покрия по-задълбочено, преди да продължа.


## Инициализиране на обект

Ако искахме да конвертираме нашата структура `Person` в клас `Person`, Swift нямаше да ни позволи да напишем това:

    class Person {
        var clothes: String
        var shoes: String
    }

Това е защото декларираме двете полета да бъдат от тип `String`, което ако си спомняш означава, че те задължително трябва да имат стойност. Това не беше проблем в структурата, защото Swift създава автоматично инициализатор за нас, който изисква да предоставим стойности за двете полета. Това не е така при класовете, така че Swift не може да бъде сигурен, че ще им бъдат дадени стойности.

Имаме три опции: да направим двете стойности optional strings, да им дадем стойности по подразбиране или да създадем наш собствен инициализатор. Първият вариант е тромав, тъй като въвежда optionals на много места в кода ни, където това не е нужно. Вторият вариант работи, но е малко разточителен, освен ако тези стойности по подразбиране действително няма да се използват. Остава ни третата опция и наистина тя е правилната: да създадем наш собствен инициализатор.

За да го направим, създаване метод в класа ни, наречен `init()`, който приема двата параметъра, които ни интересуват:

    class Person {
        var clothes: String
        var shoes: String

        init(clothes: String, shoes: String) {
            self.clothes = clothes
            self.shoes = shoes
        }
    }

Има две неща, които може да ти направят впечатление в този код.

Първо, не пишеш `func` преди своя `init()` метод, защото той е специален. Второ, тъй като имената на параметрите, които се подават, са същите като имената на полетата, които искаш да присвоиш, използваш `self.` за да укажеш ясно намерението си – "полето `clothes` на този обект трябва да присвои стойността на подадения параметър `clothes`". Можеш да им дадеш уникални имена ако искаш - твой избор.

**Важно:** Swift изисква изисква всички non-optional полета да имат стойност преди края на инициализатора или до момента, в който инициализаторът извика друг метод - в зависимост от това кое от двете настъпи първо.

## Насленяване (Inheritance)

Втората разлика между класовете и структурите е, че класовете могат да се базират един на друг, за да произведат по-големи неща. Това е известно като *class inheritance*. Това е техника, използвана широко в Cocoa Touch, дори и в най-основните програми, така че е нещо, което трябва да осмислиш.

Нека да започнем с нещо просто: клас `Singer`, който има полета, които са за име и възраст. Що се отнася до методите, ще има прост инициализатор, който да се погрижи за задаването на полетата, плюс метод `sing()`, който извежда няколко думи:

    class Singer {
        var name: String
        var age: Int

        init(name: String, age: Int) {
            self.name = name
            self.age = age
        }

        func sing() {
            print("La la la la")
        }
    }

Сега можем да създадем инстанция на този обект, като извикаме този инициализатор, а след това можем да прочетем стойностите на неговите полета и да извикаме метода му:

    var taylor = Singer(name: "Taylor", age: 25)
    taylor.name
    taylor.age
    taylor.sing()

Това е нашият базов клас, но ще продължим да градим върху него: искам да дефинирам клас `CountrySinger`, който има всичко, което класът `Singer` прави, но когато извикам `sing()` на негова инстанция, искам да отпечатам "Trucks, guitars, and liquor".

Можеш, разбира се, просто да копираш оригиналния `Singer` в нов клас, наречен `CountrySinger`, но това е мързелив начин на програмиране, който ще се върне да те преследва, ако по-късно промениш `Singer` и забравиш да копираш промените на другите места. Вместо това, Swift има по-умно решение: можем да дефинираме `CountrySinger` като наследник на `Singer` и така той ще получи неговите полета и методи, които ние ще надградим:

    class CountrySinger: Singer {

    }

Това двоеточие е магическият символ: означава "`CountrySinger` наследява `Singer`." Сега този нов клас `CountrySinger` (наречен наследник или subclass) все още не добавя нищо към `Singer` (наречен базов клас/клас-родител или superclass). Искаме той да има свой собствен метод `sing()`, но в Swift трябва да научиш нова ключова дума: `override`. Тя означава "Знам, че този метод е имплементиран в моя родителски клас, но искам да го променя в класа наследник".

Използването на ключовата дума `override` е полезно, тъй като прави намерението ти ясно. Също така позволява на Swift да провери кода ти: ако не използваш `override`, Swift няма да ти позволи да промениш метод, получен от твоя superclass, или ако използваш `override` и няма метод, който да се замени, Swift ще посочи грешката ти.

Така че трябва да използваме `override func`, ето така:

    class CountrySinger: Singer {
        override func sing() {
            print("Trucks, guitars, and liquor")
        }
    }

Сега промени начина, по който обектът `taylor` е създаден:

    var taylor = CountrySinger(name: "Taylor", age: 25)
    taylor.sing()

Ако замениш `CountrySinger` със `Singer`, трябва да можеш да видиш различните съобщения в панела с резултати.

Сега, за да направим нещата по-сложни, ще дефинираме нов клас, наречена `HeavyMetalSinger`. Но този път ще имаме ново поле, наречено `noiseLevel`, определящо колко силено този конкретен хеви метъл певец обича да вика в микрофона си.

Това поражда проблем, който трябва да бъде разрешен по особен начин:

- Swift иска всички non-optional полета да имат стойност.
- Нашият клас `Singer` няма поле `noiseLevel`.
- Трябва да създадем наш инициализатор за `HeavyMetalSinger`, който приема ниво на шум.
- Този нов инициализатор също трябва да знае какви са `name` и `age` на хеви метъл певеца, за да може да ги подаде на своя superclass `Singer`.
- Подаването на данни към родителския клас се извършва чрез извикване на метод и не можеш да извикваш никакви други методи в инициализатора, докато не дадеш стойности на всичките полета.
- Така че първо трябва да зададем стойност на собственото си поле (`noiseLevel`), след което да подадем останалите параметри към родителския клас.

Това може да звучи ужасно сложно, но в кода е лесно. Ето класа `HeavyMetalSinger`, завършен със своя собствен `sing()` метод:

    class HeavyMetalSinger: Singer {
        var noiseLevel: Int

        init(name: String, age: Int, noiseLevel: Int) {
            self.noiseLevel = noiseLevel
            super.init(name: name, age: age)
        }

        override func sing() {
            print("Grrrrr rargh rargh rarrrrgh!")
        }
    }

Забележи как инициализаторът му приема три параметъра, а след това извиква `super.init()`, за да подаде `name` и `age` на родителския клас `Singer` - но само след като собственото му поле е било зададено. Ще виждаш `super` доста често, когато работиш с обекти и това просто означава "извикай метод от класа, който съм наследил". Обикновено това означава "нека първо родителският ми клас да направи всичко, което трябва да направи, а после аз ще направя моите допълнителни неща".

Наследяването е обширна тема, така че не се притеснявай, ако още не ти е напълно ясна. Обаче има още едно нещо, което трябва да знаеш: наследяването при класовете често се разпростира на много нива. Например, А може да наследи Б, а Б може да наследи С, а С да наследи Д и т.н. Това ти позволява да създаваш функционалност и да я преизползваш в редица класове, помагайки ти да запазиш кода си модулен и лесен за разбиране.

## Работа с Objective-C код

Ако искаш метода ти да бъде извикан от някоя част на операционната система на Apple, трябва да го означиш със специален атрибут:  `@objc`. Това е кратко за “Objective-C” и този атрибут обозначава метода като наличен за изпълнение от по-стар Objective-C код – на практика по-голямата част от iOS, macOS, watchOS, and tvOS. Например, ако помолиш системата да извика твоя метод след една секунда, ще трябва да го маркираш с `@objc`.

Не се тревожи трърде много за `@objc` засега – аз ще го обяснявам в контекст по-нататък, но и Xcode винаги ще ти каже, когато имаш нужда от него. Като алтернатива, ако не искаш да използваш `@objc` за всеки отделен метод, можеш да поставиш `@objcMembers` пред своя клас, за да направиш автоматично всички негови методи налични в Objective-C.


## Стойности или референции

Когато копираш структура, всичко се дублира, включително всичките й стойности. Това означава, че промяната на едно копие на структура не променя другите копия - те са индивидуални. С класовете, всяко копие на обект сочи към един и същ оригинален обект, така че ако промениш някое от тях, всички копия се променят. В Swift наричаме структурите стойностни типове (_"value types"_), защото те просто сочат към дадена стойност, а класовете "референтни типове" (_"reference types"_), защото обектите просто споделят референции към реалната стойност.

Това е важна разлика и означава, че изборът между структури и класове е важен:

- Ако искаш да имаш едно споделено състояние, което се предава навсякъде и може да се модифицира на всяко място, се нуждаеш от класове. Можеш да ги подаваш във функции или да ги съхраняваш в масиви, да ги променяш на едно място и тези промени ще бъдат отразени в останалата част от програмата ти.
- Ако искаш да избегнеш споделеното състояние и едно копие да не може да засегне всички останали, се нуждаеш от структури. Можеш да ги подаваш във функции или да ги съхраняваш в масиви, да ги променяш на едно място и тези промени няма да се отразят където и другаде да ги използваш.

Ако трябва да обобщя тази ключова разлика между структурите и класовете, бих казал: класовете предоставят повече гъвкавост, докато структурите предлагат повече сигурност. Като основно правило, винаги използвай структури докато нямаш конкретна причина да използваш класове.
