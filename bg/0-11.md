# Функции 

Функциите ни позволяват да дефинираме преизползваеми парчета код, които изпълняват специфична функционалност. Обикновенно те са способни да приемат едни стойности, които модифицират начина, по който работят, но това не е наложително.

Нека започнем с една проста функция:

    func favoriteAlbum() {
        print("My favorite is Fearless")
    }

Ако сложим този код в playground, нищо няма да се отпечата. И да, така е правилно. Причината е, че поставихме съобщението "My favorite is Fearless" във функция, която се нарича `favoriteAlbum()`, и този код няма да се изпълни докато не я извикаме. За да извикаме функцията трябва да добавим следното: 

    favoriteAlbum()

Този код извиква функцията, която сама по себе си ще отпечата "My favorite is Fearless".

Както можем да видим, дефинираме функция, като напишем ключовата дума `func`, последвана от името на фукнцията, отваряща и затваряща скоба, и накрая един блок от код, който започва и завършва с къдрава скоба. След това можем да извикаме функцията, като напишем името й, последвано с отваряща и затваряща скоба. 

Разбира се, това е доста шеговит пример - тази функция прави едно и също нещо без значение, така че няма особен смисъл тя да съществува. Но какво, ако искаме да отпечатаме различен албум всеки път? В този случай може да кажем на Swift, че искаме функцията ни да приема стойност, когато бъде извикана, и да използваме тази стойност в нея. 

Нека направим това сега:

    func favoriteAlbum(name: String) {
        print("My favorite is \(name)")
    }

Това казва на Swift, че искаме функцията ни да приема стойност (наречена параметър), наименувана "name", която трябва да е от тип String. След това използваме string интерполация, за да добавим името на албума директно към съобщението, което отпечатваме. За да извикаме тази функция, трябва да напишем следното: 

    favoriteAlbum(name: "Fearless")

Може да се чудим какъв е смисъла, след като все още нашата логика е един ред код. Е, нека да си представим, че използваме тази функция на 20 различни места в голям проект и в даден момент главния ни дизайнер реши, че трябва да променим съобщението на "I love Fearless so much – it's my favorite!". Кое предпочитаме - да променим съобщението на едно място или на всички 20? При функциите правим промяна на едно място и тя се отразява на всяко място, където се извиква.

Една функция може да приема колкото параметъра си поискаме, така че нека да накараме нашата да приема име и година: 

    func printAlbumRelease(name: String, year: Int) {
        print("\(name) was released in \(year)")
    }

    printAlbumRelease(name: "Fearless", year: 2008)
    printAlbumRelease(name: "Speak Now", year: 2010)
    printAlbumRelease(name: "Red", year: 2012)

Имената на параметрите са важни, защото оформят самата функция. Понякога ще срещаме няколко функции наречени по един и същи начин, например `handle()`, но с различни параметри, което прави разликата в различните действия. 

## Външни и вътрешни имена на параметри

Понякога искаме параметрите ни да имат едни имена, когато викаме функцията, и други, в самата имплементация. Това означава, че когато извикваме функция, използваме почти естествен английски, но във функцията параметрите имат логични имена. Тази техника се среща доста често в Swift, така че е полезно да я разберем. 

За да демонстрираме това, нека напишем функция, която отпечатва броя букви в един string. Той е достъпен чрeз `count` (брой) променливата на string, така че може да напишем това:

    func countLettersInString(string: String) {
        print("The string \(string) has \(string.count) letters.")
    }

След като имаме функцията, може да я извикаме по този начин: 

    countLettersInString(string: "Hello")

Докато този метод работи, той е малко наблъскан. Освен това, не е нещо, което бихме казали на глас: “count letters in string string hello”.

Решението на Swift е да ни позволи да определим едно име за параметър, когато функцията се вика, и друго име в самия метод. За да използваме това ние просто трябва да напишем името на параметъра два пъти - веднъж за външно и веднъж за вътрешно ползване.

Например, може да именуваме параметъра `myString`, когато се извиква и `str` в самия метод:

    func countLettersInString(myString str: String) {
        print("The string \(str) has \(str.count) letters.")
    }
    
    countLettersInString(myString: "Hello")  

Също така може да иползваме долна черта `_` като външното име на параметъра, което казва на Swift, че не искаме да имаме външно име, ето така:

    func countLettersInString(_ str: String) {
        print("The string \(str) has \(str.count) letters.")
    }
    
    countLettersInString("Hello")
    
Това прави този ред код четим като изречение на английски: “count letters in string hello”. 

Докато в много случаи ще смятаме `_` за правилния избор, Swift програмистите обикновенно предпочитат да слагат имена на всичките си параметри. Като се замислим: защо да ни трябва думата "String" във функцията - на какво друго може да преброим буквите?

Така че, често ще срещаме външни имена на параметри, като "in" (в), "for" (за), и "with" (с), и същевременно по-смислени вътрешни имена. Така че, "Swift-oвият" начин да напишем тази функция би бил:

    func countLetters(in string: String) {
        print("The string \(string) has \(string.count) letters.")
    }

Това означава, че извикваме функцията с име на параметъра "in", което би било безсмислено вътре в нея. Но, *в* самата функция параметъра се нарича "string", което е доста по-удобно. Тъй че можем да извикаме функцията по този начин: 

    countLetters(in: "Hello")

И *това* е истински Swift код: “count letters in hello” се чете като естествено английско изречение, но същевременно кода е кратък и изчистен.

## Върнати стойности 

Swift функциите могат да връщат стойности, като напишем `->` последвано от типа данни след списъка с параметри. Веднъж щом напишем това, Swift ще осигури, че функцията ни ще върне стойност, така че в този случай ние отново правим обещание за това какво прави кода ни. 

Като пример, нека напишем функция, която връща true, ако даден албум е на Taylor Swift или false, в противен случай. Тук функцията ни приема един параметър (името на албума, който ще проверим) и ще върне Bool. 

Ето и самият код:

    func albumIsTaylor(name: String) -> Bool {
        if name == "Taylor Swift" { return true }
        if name == "Fearless" { return true }
        if name == "Speak Now" { return true }
        if name == "Red" { return true }
        if name == "1989" { return true }

        return false
    }

Ако искаме да изтренираме новите ни знания за `switch/case`, тази фунцкия би била добра възможност за това. 

Сега може да извикаме функцията с име на албум и да решим как да действаме, базирано на резултата:

    if albumIsTaylor(name: "Red") {
        print("That's one of hers!")
    } else {
        print("Who made that?!")
    }

    if albumIsTaylor(name: "Blue") {
        print("That's one of hers!")
    } else {
        print("Who made that?!")
    }
