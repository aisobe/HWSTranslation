# Навързване на Optional 

Работата с optionals може да бъде малко блудкава понякога, и всичкото това разопаковане и проверяване може да се превърне в тежка задача и да се изкушим да използваме удивителни знаци, за да принудим разопаковане на стойностите, за да можем да работим с тях. Но трябва да сме внимателни: ако принудително разопаковаме optional, който не съдържа стойност, програмата ни ще крашне. 

Swift има две техники, които биха ни помогнали да направим кода ни по-малко сложен. Първата се нарича навързване на optionals, което ни позволява да изпълним код, само ако един оptional съдържа стойност. Нека да започнем със следния код: 

    func albumReleased(year: Int) -> String? {
        switch year {
        case 2006: return "Taylor Swift"
        case 2008: return "Fearless"
        case 2010: return "Speak Now"
        case 2012: return "Red"
        case 2014: return "1989"
        default: return nil
        }
    }

    let album = albumReleased(year: 2006)
    print("The album is \(album)")


Това ще отпечата "The album is Optional("Taylor Swift")".

Ако искаме да конвертираме стойноста, която се връща от `albumReleased()` в такава само с главни букви ("TAYLOR SWIFT" вместо "Taylor Swift") можем да извикаме метода `uppercased()` на тази string. Например: 

    let str = "Hello world"
    print(str.uppercased())

Работата е там, че функцията връщна optional string: може да върне string или да върне нищо. Така че, това което правим е "ако имаме string, направи го само с главни букви и ни го върни, в противен случай не прави нищо". Точно тук идва навързването на optional, защото той ни предоставя имено това поведение.

Нека да опитаме да навържем последните два реда:

    let album = albumReleased(year: 2006)?.uppercased()
    print("The album is \(album)")

Забелязваме въпросителният знак - това е оператора за навързване на optional: всичко след него ще се изпълни, само ако стойноста преди въпросителния знак съществува. Това няма ефект върху типа на `album`, защото този ред код или ще върне име на албум само с главни букви, или няма да върне нищо - все още си е optional string. 

Може да навържем колкото променливи искаме: 

    let album = albumReleased(year: 2006)?.someOptionalValue?.someOtherOptionalValue?.whatever

Swift ще провери всяка, от ляво на дясно, докато не намери `nil`, при което ще спре.  

## Оператор за сливане на nil

Този прост аспект на Swift ще направи кода ни доста по-семпъл и сигурен, а има толкова грандиозно име, което плаши доста хора. Което е срамота, защото оператора за сливане на nil ще направи живота ни доста по-лесен, ако положим усилия да го разберем.

Това, което прави е "Използвай стойността А, ако може, но ако А е nil, тогава използвай стойността В". Това е. Доста полезно е при optional, защото ги кара да не бъдат вече толкова optional, след като предоставяме стойност, която ще бъде използвана, когато е нужно. Така че, ако А има стойност - иползваме нея. В противен случай, използваме В. И в двата случая не оставаме без стойност.

Ето и пример, нека да напишем това в playground: 

    let album = albumReleased(year: 2006) ?? "unknown"
    print("The album is \(album)")

Този двоен въпросителен знак е упоменатия оператор, като в този случай означава "ако `albumReleased()` върне стойност, задай я на променливата `album`, но ако върне nil, задай 'unknown' вместо това".

Ако погледнем в резултатите ще видим изписано "The album is Taylor Swift" - без повече optional. Това е защото Swift вече е сигурен, че ще получи истинска стойност, защото функцията ни връща или име на албум, или 'unknown'. А за нас вече не е нужно да разопаковаме стойности и да рискуваме приложението ни да крашне - гарантирано е, че ще имаме истински данни, с които да работим, което прави кода ни по-безопасен и лесен за работа.